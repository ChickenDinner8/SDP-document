# 软件设计文档

---

## 1.前端

### 1.1 顾客点餐系统

#### 1.1.1 技术选型理由

> 随着网络和移动支付的发展与普及，手机用户们更倾向于快捷方便的点餐方式。同时，微信小程序的推广为用户创造了更便捷的生活方式。因此选择微信小程序作为点餐系统，应是个能给用户带来便利的不错选择。

**MINA**

我们选择了微信小程序官方提供的开发框架MINA。

- MINA通过尽可能简单、高效的方式，让开发者在微信中开发具有原生APP体验的服务；
- MINA通过封装微信客户端提供的文件系统、数据安全等基础功能，对上层提供一整套JS API，易于开发；
- MINA提供了自己的视图层描述语言WXML和WXSS，以及基于JavaScript的逻辑层框架。并在视图层与逻辑层间提供了数据传输和事件系统，让开发者聚焦于数据与逻辑上，提高开发效率；
- MINA框架管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据，方法，生命周期函数注册进框架中，其他的一切复杂的操作都交由框架处理 。

**WEUI**

在微信开发者工具以及小程序开发文件结构目录的基础下，我们使用了WeUI框架。

  -  WeUI是由微信官方设计团队专为微信移动 Web 应用设计的 UI 库；
  -  WeUI是一套同微信原生视觉体验一致的基础样式库，令用户的使用感知更加统一；
  -  WeUI相比于原生提供了更丰富与实用的组件；
  -  WeUI的部署方法简单，使用体验也比较便捷。

#### 1.1.2 架构设计

在小程序中，文件目录主要包含一个描述整体程序的 app 和多个描述各自页面的 page。

MINA框架下的小程序主体由三个文件组成，需要放在项目的根目录，如下:

- app.js：小程序的逻辑
- app.json：小程序的公共设置
- app.wxss：小程序的公共样式表

而每一个小程序页面由四个文件组成，分别是：

- .js文件：页面逻辑文件，逻辑层由 JavaScript 编写，涵盖页面跳转，网络请求，内容载入等代码部分，将数据进行处理后发送给视图层，同时接受视图层的事件反馈
- .wxml文件：页面结构文件，描述页面布局与内容，属于小程序的视图层
- .wxss文件：页面样式表，是对于页面结构文件的修饰与UI细节的表达，也属于小程序的视图层
- .json文件：页面配置，主要描述页面的基础配置参数，例如页面标题与标题颜色等

最后生成的整体文件目录如下：

![ ](https://github.com/ChickenDinner8/ChickenDinner8.github.io/blob/master/public/img/pomelo/content.jpg?raw=true)

其中，pages文件夹下存放了所有的小程序页面的信息，每个页面又有四个文件构成。

#### 1.1.3 模块划分

根据UI模型，小程序部分的页面由五个页面组成：

- 登录页面（index），获取用户餐厅号及餐桌号信息，确认进入菜单页面
- 菜单页面（menu），获取上架菜品并点单
- 提交订单页面（submit），确认订单信息并确认提交
- 评价页面（comment），浏览其他用户评价
- 支付页面（payment），订单提交成功并支付

每个页面内包含js文件、json文件、wxml文件和wxss文件，分别处理逻辑、配置、结构和样式；再加上小程序的全局文件与资源文件，各个模块的关系如下：

![](https://github.com/ChickenDinner8/SDP-document/blob/master/Assets/SDS/relation.png?raw=true)

小程序端点餐系统结构如下：

```txt
├── project.config.json //开发工具配置
├── app.js //小程序的全局逻辑文件
├── app.json //小程序的全局配置
├── app.wxss //小程序的全局样式
├── weui.wxss //WEUI样式文件
├── images //小程序利用到的图片
|
├── pages //小程序的页面文件存放文件夹
│   ├── index //主菜单页面
│   │   ├── index.js //主菜单页面的逻辑文件
|   |   ├── index.json //主菜单页面配置文件
│   │   ├── index.wxml // 主菜单页面的结构文件
│   │   └── index.wxss  // 主菜单页面的样式文件
|   |
│   ├── comment //评价页面
│   |   ├── comment.js //评价页面的逻辑文件
│   |   ├── comment.json //评价页面配置文件
│   |   ├── comment.wxml //评价页面的结构文件
│   |   └── comment.wxss //评价页面的样式文件
|   |
│   ├── menu //菜单页面
│   |   ├── menu.js //菜单的逻辑文件
│   |   ├── menu.json //菜单配置文件
│   |   ├── menu.wxml //菜单的结构文件
│   |   └── menu.wxss //菜单的样式文件
|   |
│   ├── submit //提交订单页面
│   |   ├── submit.js //提交订单页面的逻辑文件
│   |   ├── submit.json //提交订单页面配置文件
│   |   ├── submit.wxml //提交订单页面的结构文件
│   ├── └── submit.wxss //提交订单页面的样式文件
|   |
│   ├── payment //支付页面
│   |   ├── payment.js //支付页面的逻辑文件
│   |   ├── payment.json //支付页面配置文件
│   |   ├── payment.wxml //支付页面的结构文件
│   └── └── payment.wxss //支付页面的样式文件
└── utils //公共的js代码
     ├── util.js
     └──cookie
     	└── Cookie.js

```



#### 1.1.4 软件设计技术

**MVVM**

![](https://github.com/ChickenDinner8/SDP-document/blob/master/Assets/SDS/mvvm_xcx.PNG?raw=true)

MVVM模式包含了三个部分：

- Model – 代表基本业务逻辑
- View – 显示内容
- ViewModel – 将前面两者联系在一起的对象



MVVM是MVC设计模式的更先进进化，符合它进化的方向。 数据源被强化，不单只是请求过来的数据还包括，数据在本页面应该处于的状态，数据源对象在本页面或本模块中共享，一旦一个地方改变，本页面或模块中的所有数据源的内容都改变，保证了数据的一致性。它的全局共享性是它的一大特色。 

从控制器分离出来的非页面间关系部分和http请求部分，产生请求操作类.它可以被控制器调用，也可以被view调用。它负责数据数据请求参数的组装，甚至上次请求的暂存，服务器请求过来的数据转化为数据源数据，进行简单数据处理。我们称它为View-Model。一个页面可以有一个View-Model，也可以有多个View-Model，这个可以根据页面的复杂度和View(调用View-Model的View)是否在其它页面重用。若有View调用请求对象发送请求并且被其它页面重用该View，那么该View不能共享数据源。View-Model一般持有本页面或本模块的共享数据源。 



**优点：**

MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点

1. 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
2. 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。
3. 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。
4. 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。



### 1.2 商家管理系统

#### 1.2.1 技术选型理由

**Vue.js**

- Vue是一个轻巧、高性能、可组件化的MVVM库，并且拥有非常容易上手的API； 
- Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合；
- Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用；
- Vue 也支持响应式、双向数据绑定等 MVVM 特性，能够很好地支持丰富的用户交互体验。

**IView**

- iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品；
- iView具有友好的 API ，能够自由灵活地使用空间，并且支持自定义主题。

**axios**

- axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端 
- axios是一个ajax的封装，是vue.js2.0之后官方推荐的ajax插件，相对于之前官方推荐的vue-resource，axios有着更大的适用性，不仅可以使用在客户端，也可以使用在服务器端，也拥有更加简单实用的API。

**webpack：**

- 当下前端最流行的构建打包工具，利用 webpack 搭配相应的 loader，可以在前端项目中使用 es6 进行开发，效率更高，开发完成后，webpack 还可以将代码编译到 es5 以兼容大部分浏览器；

#### 1.2.2 架构设计

在商家端项目中，我们主要分为以下的包：

- build：开发环境和项目构建的代码 
- config：项目进行webpack打包时依照的配置
- src：项目源码，里面又主要分为
  - assets：存放项目资源文件
  - components：项目中自定义的组件
  - router：项目路由配置
- dist：打包生成的产品文件

`build`包根据`config`中的配置调整webpack打包规则，将`src`中的源码进行打包。另外，项目构建后，还会生成`dist`包，为构建后的产品文件。 

![](https://github.com/ChickenDinner8/SDP-document/blob/master/Assets/Merchant-end/package.png?raw=true)

#### 1.2.3 模块划分

商家端管理系统前端分为6个页面：

- Login:：商家登录页面
- RestaurantInfo：商家信息页面（待开发）
- Menu：菜单管理页面
- Order：查看订单页面
- QRcode：定制餐桌二维码页面
- Setting：个人设置页面（待开发）



采取单页面Web应用的思想，将网页的各个部分抽象为一个个组件，在一个页面内通过组件的切换，实现各种跳转功能，组件设计及功能如下：

- Addwindow.vue：添加菜品的弹窗组件，商家在此弹窗输入菜品名称、菜品描述、菜品定价，以及上传菜品图片
- Dish.vue：用于显示每个菜品的组件，包括菜品名称、菜品描述、菜品描述和菜品销量，以及对应的图片
- Editwindow.vue：修改菜品信息的弹窗组件，商家在此弹窗对菜品名称、菜品描述、菜品定价或菜品图片进行修改
- Home.vue：主页组件，在此渲染导航栏等UI布局，并为其它组件的切换提供router入口
- Login.vue：登录页面组件，商家在此通过输入用户名及密码登录进入点餐系统
- Menu.vue：菜单管理页面组件，商家在此对菜单上的菜品进行增、删、改操作
- Order.vue：订单管理页面组件，商家在此可查看订单信息
- QRcode.vue：二维码页面组件，商家在此页面输入



组件间的包含关系如下：

—— Login.vue

—— Home.vue

​	—— Menu.vue

​		—— Addwindow.vue

​		—— Dish.vue

​			—— Editwindow.vue

​	—— Order.vue

​	—— QRcode.vue



实现时用到了父子组件间的传值：

1）添加菜品时，作为子组件的添加菜品弹窗将数据向父组件菜单页面组件进行传递，同时父组件向子组件传递数据，将商家上一次的操作内容清空；

2）修改菜品时，作为子组件的修改菜品弹窗将数据向父组件菜品组件进行传递，修改父组件中显示的菜品信息，同时父组件向子组件传递数据进行同步，使得在下一次点开修改菜品信息窗口时，显示修改后的菜品信息。



#### 1.2.4 软件设计技术

**MVVM**

MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。

MVVM的思路是给view里面的各种控件也定义一个对应的数据对象，这样，只要修改这个数据对象，view里面显示的内容就自动跟着刷新，而在view 里做了任何操作，这个数据对象也跟着自动更新。具体说明如下：

　　ViewModel：与界面(view)对应的Model。因为数据库结构往往是不能直接跟界面控件一一对应上的，所以，需要再定义一个数据对象专门对应view上的控件。而ViewModel的职责就是把model对象封装成可以显示和接受输入的界面数据对象。

　　简单的说，ViewModel就是View与Model的连接器，View与Model通过ViewModel实现双向绑定。



**组件化设计思想与单文件组件文件组织方法**

Vue框架一个重要的思想就是将页面各个部分组件化，并尽可能将复用率较高的部分再继续抽离出来，写成一个独立的组件，再在其它组件内嵌套调用，简化代码，也能提高变成的效率。

进行文件组织时，使用单文件组件的组织形式，每一个组件以一个单独的.vue文件进行封装，并且将组件的样式、逻辑等代码，一并封装到同一个文件内，可以大大方便组件的管理和拓展。



## 2. 服务端

### 2.1 技术选型理由

本节阐述了本团队在进行软件设计时所考虑的因素

1. 首先考虑简单性，简单的设计可以降低复杂度，放松对开发人员技术水平的要求，同时也增强了软件的可靠性
2. 第二是可维护性，在面对可维护性强的代码时，开发人员不仅可以较为轻松地理解代码，还能在修改代码的同时最小化此次修改对软件的冲击
3. 第三是可拓展性，可拓展的设计允许开发人员方便地为软件添加功能或增强性能
4. 第四是健壮性，软件在运行时能够容忍一定的错误
5. 最后是性能，软件有较快的响应速度和处理速度

### 2.2 架构设计

- 基于简单性的考虑，本项目采用浏览器/服务器架构
- 为了提高开发效率，同时增强代码的可维护性和可拓展性，本项目采取了前后端分离的架构模式
- 由于REST API的可拓展性和健壮性比较强，服务端的API采用了这种设计

综上所述，前端的顾客端以微信小程序的形式开发，前端的餐厅端以Web页面的形式开发，而服务端则以Django框架为依托向前端提供REST API服务

### 2.3 模块划分
服务端的模块划分：大体上分为登录、控制器、数据对象、静态文件服务、配置五类模块

- 登陆模块负责用户的登录认证，代码由auth_required_decorator.py组成
- 控制器模块负责处理URL请求，代码由urls.py以及各个以"_ctrl"为后缀的python代码文件组成
- 数据对象负责数据库数据到对象之间的映射，代码由models.py组成
- 静态文件服务主要由nginx的Docker镜像构成，模块由Dockerfile_nginx、nginx_app.conf以及各项静态文件等组成
- 配置模块负责配置服务器的运行状态、与外部数据库的连接、Travis的使用、Docker镜像的构建等，模块由settings.py、.travis.yml和docker-compose.yml等文件组成

### 2.4 软件设计技术

- 结构化程序设计，一个例子是控制器模块的代码
- RESTful API， 参见urls.py
- 容器化技术，参见docker-compose.yml
